package com.geishatokyo.apollon.action

import com.geishatokyo.apollon.battle.ApiEvent._
import com.geishatokyo.apollon.battle._
import com.geishatokyo.apollon.error.ErrorCode
import com.geishatokyo.apollon.logging.{Action, ActionLogger}
import com.geishatokyo.apollon.model.api._
import com.geishatokyo.apollon.model.api.response._

import scala.concurrent.Future

//@insert[imports]

/**
 * AutoGenerated
 */
object BattleAction {

  implicit def ec = scala.concurrent.ExecutionContext.Implicits.global

  //@insert[methods]
  def postCreateRoom(): CreateRoomResponseInfo = {
    ActionLogger.getLogger.log(-1, Action.BattlepostCreateRoom.start)
    val code = BattleManager.createRoom()
    CreateRoomResponseInfo(code)
  }
  def postJoinRoom(roomCode: String, playerData: String): Future[JoinRoomResponseInfo] = {
    ActionLogger.getLogger.log(-1, Action.BattlepostJoinRoom.start, "roomCode" -> roomCode, "playerData" -> playerData)
    // フリー用の簡略化でbattleIdをroomCodeとして使用している
    val battleId = safeStringToInt(roomCode).getOrElse(ErrorCode.BattleRoomNotFoundByRoomCode().throws)
    BattleManager.join(battleId, playerData).transform({
      case (token : String, seed : Int) => JoinRoomResponseInfo(battleId.toInt, seed, token)
    }, e => e)
  }
  def postAcceptRoom(battleId: Long, playerToken: String): Future[AcceptRoomResponseInfo] = {
    ActionLogger.getLogger.log(-1, Action.BattlepostAcceptRoom.start, "battleId" -> battleId, "playerToken" -> playerToken)
    BattleManager.accept(battleId, playerToken).transform({
      case (playerData, isLeft) => AcceptRoomResponseInfo(playerData, isLeft)
    }, e => e)
  }
  def postLeaveRoom(battleId: Long, playerToken: String, reason: String): LeaveRoomResponseInfo = {
    ActionLogger.getLogger.log(-1, Action.BattlepostLeaveRoom.start, "battleId" -> battleId, "playerToken" -> playerToken, "reason" -> reason)
    BattleManager.leave(battleId, playerToken, reason)
    LeaveRoomResponseInfo()
  }
  def postReceiveApiEvents(battleId: Long, playerToken: String, sinceApiEventId: Long): Future[ReceiveApiEventsResponseInfo] = {
    ActionLogger.getLogger.log(-1, Action.BattlepostReceiveApiEvents.start, "battleId" -> battleId, "playerToken" -> playerToken, "sinceApiEventId" -> sinceApiEventId)
    BattleManager.setReceiver(battleId, playerToken, sinceId = sinceApiEventId).transform({
      case Nil =>
        ReceiveApiEventsResponseInfo(Nil, sinceApiEventId)
      case apiEvents : List[ApiEvent] =>
        ReceiveApiEventsResponseInfo(apiEvents.map({
          case LeaveApiEvent(eventId, _, reason) => LeaveApiEventInfo(eventId, "LEAVE", reason)
          case OperationApiEvent(eventId, _, operation) => OperationApiEventInfo(eventId, "OPERATION", operation)
        }), apiEvents.map(_.eventId).max)
    }, e => e)
  }
  def postSendOperation(battleId: Long, playerToken: String, operation: String): Future[SendOperationResponseInfo] = {
    ActionLogger.getLogger.log(-1, Action.BattlepostSendOperation.start, "battleId" -> battleId, "playerToken" -> playerToken, "operation" -> operation)
    BattleManager.operation(battleId, playerToken, operation).transform({
      case apiEvent : ApiEvent =>
        SendOperationResponseInfo(apiEvent.eventId)
    }, e => e)
  }

  private def safeStringToInt(str: String): Option[Int] = {
    import scala.util.control.Exception._
    catching(classOf[NumberFormatException]) opt str.toInt
  }
}
